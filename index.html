<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="manifest" href="manifest.json" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="application-name" content="WICG" />
    <meta name="format-detection" content="telephone=no" />
    <script src="js/lib/hyperhtml.js" async></script>
    <link rel="stylesheet" href="styles/style.css" />
    <link href="images/logo.svg" rel="icon" sizes="any" />
    <title>Web Incubator Community Group (WICG)</title>
  </head>
  <body>
    <header role="banner">
      <div>
        <h1>
          <img src="images/logo.svg" height="40" width="40" alt="" />Web
          Incubator CG
        </h1>
      </div>
    </header>
    <main role="main">
      <section id="join">
        <h2 class="visuallyhidden">Join our community!</h2>
        <ul class="buttonlist fancypill">
          <li>
            <a href="https://www.w3.org/community/wicg/">Join</a>
          </li>
          <li>
            <a href="https://www.w3.org/community/wicg/proposals">Proposal</a>
          </li>
          <li>
            <a href="https://github.com/WICG/">GitHub</a>
          </li>
        </ul>
        <p>
          Join our community of developers and browser makers to define the next
          generation of web technologies.
        </p>
      </section>
      <section id="about">
        <h2>About the WICG</h2>
        <p class="about">
          The Web Incubator Community Group (WICG) is a community group of the
          <a href="https://www.w3.org/">World Wide Web Consortium (W3C)</a> that
          incubates new web platform features. The WICG is a place for
          experimentation and discussion of new web platform features. The WICG
          is not a standards body, but rather a forum for discussion and
          incubation of new ideas that could one day become web standards.
        </p>
      </section>
      <section id="proposals">
        <h2>Making a proposal</h2>
        <p>
          If you are interested in contributing a proposal to the WICG, please
          see our
          <a href="https://github.com/WICG/proposals">proposals repository</a>
          on GitHub. The usual steps for incubating a proposal in the WICG is as
          follows:
        </p>
        <ol>
          <li>
            <a href="https://github.com/WICG/proposals">Submit a proposal</a>
            outlining your idea.
          </li>
          <li>Get feedback and improve your proposal.</li>
          <li>Find collaborators and create a GitHub repository.</li>
          <li>Work on your proposal and seek consensus from the community.</li>
          <li>
            Advocate for adoption of your proposal to the
            <a href="https://www.w3.org/">W3C</a> or the
            <a href="https://whatwg.org/">WHATWG</a> for standardization.
          </li>
        </ol>
      </section>
      <section id="incubations">
        <h2>Active Incubations</h2>
        <p>
          There are <span class="incubation-count generated"></span> incubations
          actively being worked on by the WICG community. The
          <a href="https://en.wikipedia.org/wiki/Median">median</a> incubation
          time is <span class="median-duration generated"></span>. The longest
          running incubation is
          <a class="longest-incubation-name generated"></a>, which has been
          incubating for approximately
          <span class="longest-incubation-duration generated"></span>. The
          shortest incubation is
          <a class="shortest-incubation-name generated"></a>, which has been
          incubating for
          <span class="shortest-incubation-duration generated"></span>.
        </p>
        <p>
          Incubations are listed from most active participation to least active,
          based on the community's interaction with issues and incoming commits.
        </p>
        <dl class="docslist multicol" id="incubation-list"></dl>
      </section>
      <section id="archived">
        <h2>Archived incubations</h2>
        <p>
          The following
          <span class="archived-count generated"></span> incubations have been
          archived and are no longer actively being pursued by the WICG
          community. This indicates that either they have successfully
          progressed to the
          <a href="https://www.w3.org/2021/Process-20211102/#rec-track"
            >recommendation track</a
          >
          in a <a href="https://www.w3.org/">W3C</a>
          <a href="https://www.w3.org/groups/wg/">Working Group</a> or the
          <a href="https://whatwg.org/">WHATWG</a>, or they have been abandoned.
        </p>
        <p>
          The
          <a href="https://en.wikipedia.org/wiki/Median">median</a>
          time for archived incubations is
          <span class="median-archived-duration generated"></span>. The shortest
          incubation before being archived was
          <span class="shortest-archived-incubation-name generated"></span>,
          which lasted for approximately
          <span class="shortest-archived-incubation-duration generated"></span>.
          The longest running incubation before being archived was
          <a class="longest-archived-incubation-name generated"></a>, which
          lasted for approximately
          <span class="longest-archived-incubation-duration generated"></span>.
        </p>
        <dl class="docslist multicol" id="archived-incubation-list"></dl>
      </section>
      <section id="resources">
        <h2>Useful Resources</h2>
        <ul class="linkslist">
          <li>
            <a href="https://wicg.github.io/admin/charter.html"
              >Group Charter</a
            >
          </li>
          <li>
            <a href="https://www.w3.org/community/wicg/participants">
              WICG Participants
            </a>
          </li>
          <li>
            <a href="https://lists.w3.org/Archives/Public/public-wicg/">
              Mailing list
            </a>
          </li>
        </ul>
      </section>
    </main>
    <footer role="contentinfo">
      <ul class="buttonlist">
        <li>
          <a href="https://twitter.com/wicg_">
            <img
              src="images/twitter_white.svg"
              width="30"
              height="30"
              alt="Follow us on Twitter!"
            />
          </a>
        </li>
        <li>
          <a href="https://github.com/WICG/">
            <img
              src="images/github.svg"
              width="30"
              height="30"
              alt="Joing us on Github!"
            />
          </a>
        </li>
        <li>
          <a href="http://w3.org">
            <img
              src="images/w3c_white.svg"
              height="30"
              width="61"
              alt="Join the W3C!"
            />
          </a>
        </li>
      </ul>
      <section id="attributions">
        <h2 class="visuallyhidden">Attributions</h2>
        <p>
          <small>
            Icons: Document by
            <a href="https://icons8.com"> Icons8</a>, Link made by
            <a href="http://simpleicon.com"> SimpleIcon</a>, from
            <a href="https://www.flaticon.com"> Flaticon</a>. Header font is
            "Nexa", from <a href="https://www.fontfabric.com"> Fontfabric</a>.
          </small>
        </p>
      </section>
    </footer>
    <aside id="update-toast">
      <p>
        Site has been updated!
        <button id="refresh">refresh?</button>
        <button id="dismiss">No thanks!</button>
      </p>
    </aside>
    <script>
      "use strict";

      async function fillArchivedSpecs(jsonPromise) {
        const archivedIncubationList = hyperHTML.hyper(
          document.getElementById("archived-incubation-list")
        );
        archivedIncubationList`${{
          placeholder: "Loading archived specs...",
          any: jsonPromise.then((specs) => specs.map(toArchivedListItem)),
        }}`;
      }
      //

      async function fillSpecs(jsonPromise) {
        const incubationList = hyperHTML.hyper(
          document.getElementById("incubation-list")
        );
        incubationList`${{
          placeholder: "Loading specs...",
          any: jsonPromise.then((specs) => specs.map(toListItem)),
        }}`;
      }

      function calculateProjectDurationStats(
        incubations,
        { usePushDate = false }
      ) {
        const currentDate = new Date();
        const durations = incubations.map((incubation) => {
          const createdDateTime = new Date(incubation.created_at);
          const fromDate = usePushDate
            ? new Date(incubation.pushed_at)
            : currentDate;
          const durationInMs = fromDate - createdDateTime;
          const href = incubation.spec || incubation.repo;

          return {
            name: incubation.name,
            duration: durationInMs,
            href,
            description: incubation.description,
          };
        });

        const medianDurationInMs = calculateMedian(
          durations.map((duration) => duration.duration)
        );
        const longestDuration = durations.reduce((longest, duration) =>
          duration.duration > longest.duration ? duration : longest
        );
        const shortestDuration = durations.reduce((shortest, duration) =>
          duration.duration < shortest.duration ? duration : shortest
        );

        const medianDuration = formatDuration(medianDurationInMs);
        const longestDurationFormatted = formatDuration(
          longestDuration.duration
        );
        const shortestDurationFormatted = formatDuration(
          shortestDuration.duration
        );
        return {
          medianDuration: medianDuration,
          longestDuration: {
            ...longestDuration,
            duration: longestDurationFormatted,
          },
          shortestDuration: {
            ...shortestDuration,
            duration: shortestDurationFormatted,
          },
        };
      }

      function calculateMedian(numbers) {
        const sortedNumbers = numbers.slice().sort((a, b) => a - b);
        const midIndex = Math.floor(sortedNumbers.length / 2);

        if (sortedNumbers.length % 2 === 0) {
          return (sortedNumbers[midIndex - 1] + sortedNumbers[midIndex]) / 2;
        } else {
          return sortedNumbers[midIndex];
        }
      }

      function formatDuration(durationInMs) {
        const durationInDays = Math.floor(durationInMs / (1000 * 60 * 60 * 24));
        const durationInYears = Math.floor(durationInDays / 365);
        const durationInMonths = Math.floor((durationInDays % 365) / 30);
        return toHumanReadableYearsAndMonths({
          years: durationInYears,
          months: durationInMonths,
        });
      }

      function normalizeDescription(description) {
        description = description?.trim();
        if (
          // If description does not end with a period or question mark, don't add one.
          description &&
          !description.endsWith(".") &&
          !description.endsWith("?")
        ) {
          description += ".";
        }
        return description;
      }

      function toArchivedListItem(entry) {
        const { name, repo, spec, stars } = entry;
        /** @type {string} */
        const description = normalizeDescription(entry.description);
        const href = repo;
        // Incubation time in years and months. We use pushed_at as Github API
        // does not provide an archive date.
        const incubationYearsAndMonths = toHumanReadableYearsAndMonths(
          getYearsAndMonths(entry.created_at, entry.pushed_at)
        );
        // Update date suitable for the datetime attribute
        const pushedAt = new Date(entry.pushed_at);
        // Pretty date only showing the month and year
        const prettyUpdateDate = pushedAt.toLocaleDateString("en-US", {
          month: "long",
          year: "numeric",
        });
        return hyperHTML`<div class="incubation"><dt>
          <a href="${href}" class="spec">${name}</a><a href="${repo}">
          <img src="images/gh32px.png" alt="GitHub repo" width="16" height="16">
          </a>
          </dt>
            <dd class="description">
            ${
              description
                ? hyperHTML`${description}`
                : "No description available."
            }
            </dd>
            <dd class="meta">
              Incubated for <b>${incubationYearsAndMonths}</b>.
              Work stopped approx. <b><time datetime="${pushedAt.toISOString()}">${prettyUpdateDate}</time></b>.
            </dd>
          </div>
        `;
      }

      function toListItem(entry) {
        const { name, repo, spec, stars } = entry;
        /** @type {string} */
        let description = entry.description?.trim() ?? null;
        if (
          // If description does not end with a period or question mark, don't add one.
          description &&
          !description.endsWith(".") &&
          !description.endsWith("?")
        ) {
          description += ".";
        }
        const href = spec || repo;
        // Incubation time in years and months
        const incubationYearsAndMonths = toHumanReadableYearsAndMonths(
          getYearsAndMonths(entry.created_at)
        );
        // Date suitable for the datetime attribute
        const createdDateTime = new Date(entry.created_at).toISOString();
        // Update date suitable for the datetime attribute
        const updatedDateTime = new Date(entry.updated_at).toISOString();
        // Pretty date only showing the month and year
        const prettyUpdateDate = new Date(entry.updated_at).toLocaleDateString(
          "en-US",
          { month: "long", year: "numeric" }
        );
        const starsAria = `${stars} stars on GitHub`;
        return hyperHTML`<div class="incubation"><dt>
          <a href="${href}" class="spec">${name}</a><a href="${repo}">
          <img src="images/gh32px.png" alt="GitHub repo" width="16" height="16">
          </a>
          </dt>
            <dd class="description">
            ${
              description
                ? hyperHTML`${description}`
                : "No description available."
            }
            </dd>
            <dd class="meta">
              Incubating for <b><time datetime="${createdDateTime}">${incubationYearsAndMonths}</time></b>.
              Last updated <b><time datetime="${updatedDateTime}">${prettyUpdateDate}</time></b> |
              <span class="github-stars" aria-label="${starsAria}" title="${starsAria}">★ ${stars}</span>.
            </dd>
          </div>
        `;
      }

      function getYearsAndMonths(
        dateString,
        toDateString = new Date().toISOString()
      ) {
        const inputDate = new Date(dateString);
        const toDate = new Date(toDateString);

        // Calculate the difference in months between the two dates
        const diffMonths =
          (toDate.getFullYear() - inputDate.getFullYear()) * 12 +
          (toDate.getMonth() - inputDate.getMonth());

        // Calculate the number of years and months from the difference in months
        const years = Math.floor(diffMonths / 12);
        const months = diffMonths % 12;
        return { years, months };
      }

      function toHumanReadableYearsAndMonths({ years, months }) {
        // Return the result as a string using a switch statement
        switch (true) {
          case years === 0 && months === 0:
            return "less than a month";
          case years === 0:
            return `${months} month${months !== 1 ? "s" : ""}`;
          case months === 0:
            return `${years} year${years !== 1 ? "s" : ""}`;
          default:
            return `${years} year${years !== 1 ? "s" : ""} and ${months} month${
              months !== 1 ? "s" : ""
            }`;
        }
      }

      async function fillStats(jsonPromise) {
        const incubationCount = hyperHTML.hyper(
          document.querySelector(".incubation-count")
        );
        incubationCount`${{
          placeholder: "",
          any: jsonPromise.then((specs) => `${specs.length}`),
        }}`;

        const { medianDuration, longestDuration, shortestDuration } =
          calculateProjectDurationStats(await jsonPromise, {
            usePushDate: false,
          });

        // Median
        const medianDurationElement = hyperHTML.hyper(
          document.querySelector(".median-duration")
        );
        medianDurationElement`${medianDuration}`;

        // Longest incubation
        const longestDurationNameElement = document.querySelector(
          ".longest-incubation-name"
        );
        hyperHTML.hyper(longestDurationNameElement)`${longestDuration.name}`;
        longestDurationNameElement.href = longestDuration.href;
        if (longestDuration.description) {
          longestDurationNameElement.title = longestDuration.description;
        }
        const longestDurationDurationElement = hyperHTML.hyper(
          document.querySelector(".longest-incubation-duration")
        );
        longestDurationDurationElement`${longestDuration.duration}`;

        // Shortest incubation
        const shortestDurationNameElement = document.querySelector(
          ".shortest-incubation-name"
        );
        hyperHTML.hyper(shortestDurationNameElement)`${shortestDuration.name}`;
        shortestDurationNameElement.href = shortestDuration.href;
        if (shortestDuration.description) {
          shortestDurationNameElement.title = shortestDuration.description;
        }
        const shortestDurationDurationElement = hyperHTML.hyper(
          document.querySelector(".shortest-incubation-duration")
        );
        shortestDurationDurationElement`${shortestDuration.duration}`;
      }

      async function fillArchiveStats(archivedSpecs) {
        const archivedCount = hyperHTML.hyper(
          document.querySelector(".archived-count")
        );
        archivedCount`${{
          placeholder: "",
          any: archivedSpecs.then((specs) => `${specs.length}`),
        }}`;
        const specs = await archivedSpecs;
        const { medianDuration, longestDuration, shortestDuration } =
          calculateProjectDurationStats(specs, {
            usePushDate: true,
          });
        const medianDurationElement = hyperHTML.hyper(
          document.querySelector(".median-archived-duration")
        );
        medianDurationElement`${medianDuration}`;
        // Longest incubation
        const longestDurationNameElement = document.querySelector(
          ".longest-archived-incubation-name"
        );
        hyperHTML.hyper(longestDurationNameElement)`${longestDuration.name}`;
        const longestDurationDurationElement = document.querySelector(
          ".longest-archived-incubation-duration"
        );
        hyperHTML.hyper(
          longestDurationDurationElement
        )`${longestDuration.duration}`;

        // Shortest incubation
        const shortestDurationNameElement = document.querySelector(
          ".shortest-archived-incubation-name"
        );
        hyperHTML.hyper(shortestDurationNameElement)`${shortestDuration.name}`;
        const shortestDurationDurationElement = document.querySelector(
          ".shortest-archived-incubation-duration"
        );
        hyperHTML.hyper(
          shortestDurationDurationElement
        )`${shortestDuration.duration}`;
      }

      window.onload = async () => {
        const activeSpecs = fetch("./data/active.json").then((r) => r.json());
        const archivedSpecs = fetch("./data/archived.json").then((r) =>
          r.json()
        );
        const promiseToFillSpecs = fillSpecs(activeSpecs);
        const promiseToFillStats = fillStats(activeSpecs);
        const promiseToFillArchivedSpecs = fillArchivedSpecs(archivedSpecs);
        const promiseToFillStatsForArchivedSpecs =
          fillArchiveStats(archivedSpecs);

        if (!navigator.serviceWorker) {
          return;
        }
        let reg;
        try {
          reg = await navigator.serviceWorker.register("sw.js");
        } catch (err) {
          console.error(err);
          return;
        }

        if (!navigator.serviceWorker.controller) {
          return;
        }

        if (reg.installing) {
          trackInstallation(reg.installing);
          return;
        }

        if (reg.waiting) {
          updateReady(reg.waiting);
          return;
        }

        reg.addEventListener("updatefound", () => {
          trackInstallation(reg.installing);
        });

        navigator.serviceWorker.addEventListener("controllerchange", () => {
          window.location.reload();
        });

        // Now wait for the content to get rendered
        await Promise.all([
          promiseToFillSpecs,
          promiseToFillStats,
          promiseToFillArchivedSpecs,
          promiseToFillStatsForArchivedSpecs,
        ]);

        function trackInstallation(sw) {
          sw.addEventListener("statechange", () => {
            switch (sw.state) {
              case "installed":
                updateReady(sw);
                break;
            }
          });
        }

        function updateReady(sw) {
          console.info("Update ready");
          const toast = document.querySelector("#update-toast");
          const refresh = document.querySelector("#refresh");
          const dismiss = document.querySelector("#dismiss");
          toast.classList.add("show");
          dismiss.onclick = () => toast.classList.remove("show");
          refresh.onclick = () => {
            toast.classList.remove("show");
            // Let SW know it can take over
            sw.postMessage({
              action: "skipWaiting",
            });
          };
        }
      };
    </script>
  </body>
</html>
